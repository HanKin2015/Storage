# bitmap
参考：https://blog.csdn.net/2302_79539362/article/details/141173519

## 1、位图
位图（Bitmap）是一种非常高效的数据结构，主要用于快速查找、去重、排序等操作，特别是在处理大数据集时非常有用。它通过将数据集合中的每个元素映射到一个二进制位（bit）上来工作，每个位表示集合中是否存在该元素。

## 2、实现一个简略的位

### 2-1、准备
1个比特位映射一个值，那么一个int类型就可以映射32个数值（4x8=32）
1个比特位可以表示0或1，当为0时，我们认为该值不存在，否则存在

怎么知道一个数pos在映射到哪个位置?
假设用一个int类型的数组set来储存位图，一个int类型32个比特位
通过int x=pos/32，求出pos位于_set【x]中
再通过 int y =pos%32,求出pos位于_set[x]中具体第几个比特位

怎么改变y位置的值?
通过位运算

### 2-2、将pos值映射的位置置为1
先将1左移动y位，再用原来y位置的值|上该值即可

### 2-3、将pos值映射的位置置为0
先将1左移动y位，再取反，最后用原来y位置的值&上该值即可

### 2-4、判断pos是否存在
先将1左移动y位，再用原来y位置的值&上该值，若之后的值不等于0，说明y位置的值存在

## 3、布隆过滤器
将哈希与位图结合，即布隆过滤器。

布隆过滤器是由布隆（Burton Howard Bloom）在1970年提出的 一种紧凑型的、比较巧妙的概率型数据结构，特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”，它是用多个哈希函数，将一个数据映射到位图结构中。此种方式不仅可以提升查询效率，也可以节省大量的内存空间。

布隆过滤器的思想是将一个元素用多个哈希函数映射到一个位图中，因此被映射到的位置的比特位一定为1。所以可以按照以下方式进行查找：分别计算每个哈希值对应的比特位置存储的是否为零，只要有一个为零，代表该元素一定不在哈希表中，否则可能在哈希表中。
注意：布隆过滤器如果说某个元素不存在时，该元素一定不存在，如果该元素存在时，该元素可 能存在，因为有些哈希函数存在一定的误判。
比如：在布隆过滤器中查找"alibaba"时，假设3个哈希函数计算的哈希值为：1、7，10刚好和其他元素的比特位重叠，此时布隆过滤器告诉该元素存在，但实该元素是不存在的。

布隆过滤器不能直接支持删除工作，因为在删除一个元素时，可能会影响其他元素。
计数器布隆过滤器（Counting Bloom Filter）：
计数器布隆过滤器是对传统布隆过滤器的一种扩展，它将位数组中的每个位扩展为一个小的计数器。当插入元素时，对应的k个计数器（k为哈希函数的数量）增加1；当删除元素时，对应的计数器减少1。这样，即使某个位置被多个元素共享，也能通过减少计数器的值来模拟删除操作。然而，这种方法需要更多的存储空间，并且存在计数回绕（counter overflow）的风险。
使用额外的数据结构：
如果删除操作不是非常频繁，且可以接受一定的性能开销，可以考虑在布隆过滤器之外维护一个额外的数据结构（如哈希表）来记录需要删除的元素。在查询元素时，先检查这个额外的数据结构，如果元素在其中，则认为元素不存在于布隆过滤器中，即使布隆过滤器可能误判其存在。这种方法虽然可以模拟删除操作，但会增加额外的存储和查询开销，并且需要定期清理或同步这两个数据结构以保持一致性。
重新构建布隆过滤器：
对于需要频繁删除操作的应用场景，如果元素的数量不是非常大，可以考虑在删除操作较多时重新构建布隆过滤器。即，将当前所有需要保留的元素重新插入到一个新的布隆过滤器中，并丢弃旧的布隆过滤器。这种方法可以彻底清除不再需要的元素，但需要重新计算哈希值和构建位数组，可能会带来较大的性能开销。

## 4、面试题
https://blog.csdn.net/YYDsis/article/details/134374414
