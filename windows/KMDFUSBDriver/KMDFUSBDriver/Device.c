/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, KMDFUSBDriverCreateDevice)
#pragma alloc_text (PAGE, KMDFUSBDriverEvtDevicePrepareHardware)
#endif


NTSTATUS
KMDFUSBDriverCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
	Info("");

    WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;
    WDF_OBJECT_ATTRIBUTES        deviceAttributes;
    PDEVICE_CONTEXT              deviceContext;
    WDFDEVICE                    device;
    NTSTATUS                     status;
	//PCAMERA_EXTENSION            extension = NULL;

    PAGED_CODE();

    WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);
    pnpPowerCallbacks.EvtDevicePrepareHardware = KMDFUSBDriverEvtDevicePrepareHardware;
    WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

	//标记为过滤驱动
	WdfFdoInitSetFilter(DeviceInit);

	//创建设备的清除回调
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);
	//WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, CAMERA_EXTENSION);
	deviceAttributes.EvtCleanupCallback = DeviceCleanup;

    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);
	if (!NT_SUCCESS(status)) {
		Err("WdfDeviceCreate failed");
		return status;
	}
#if 0
	extension = GetExtension(device);

	extension->ConfigSize = 0;
	extension->ConfigData = NULL;
	extension->DeviceData = NULL;
	extension->DeviceSize = 0;
	extension->IsInit = FALSE;
	extension->PhyDevice = NULL;
	extension->vendor = 0;
	extension->product = 0;

	memset(extension->DeviceName, 0, sizeof(extension->DeviceName));
#endif
    //
    // Get a pointer to the device context structure that we just associated
    // with the device object. We define this structure in the device.h
    // header file. DeviceGetContext is an inline function generated by
    // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
    // This function will do the type checking and return the device context.
    // If you pass a wrong object handle it will return NULL and assert if
    // run under framework verifier mode.
    //
    deviceContext = DeviceGetContext(device);

    //
    // Initialize the context.
    //
    deviceContext->PrivateDeviceData = 0;
#if 0
    //
    // Create a device interface so that applications can find and talk
    // to us.
    //
    status = WdfDeviceCreateDeviceInterface(
        device,
        &GUID_DEVINTERFACE_KMDFUSBDriver,
        NULL // ReferenceString
        );

    if (NT_SUCCESS(status)) {
        //
        // Initialize the I/O Package and any Queues
        //
        status = KMDFUSBDriverQueueInitialize(device);
    }
#endif
    return status;
}

NTSTATUS
KMDFUSBDriverEvtDevicePrepareHardware(
    _In_ WDFDEVICE Device,
    _In_ WDFCMRESLIST ResourceList,
    _In_ WDFCMRESLIST ResourceListTranslated
    )
/*++

Routine Description:

    In this callback, the driver does whatever is necessary to make the
    hardware ready to use.  In the case of a USB device, this involves
    reading and selecting descriptors.

Arguments:

    Device - handle to a device

Return Value:

    NT status value

--*/
{
	Info("");

	Info("PrepareHardware enter++++++++++++++++++++++++++++++");
	DeviceListAdd(Device);
	Info("PrepareHardware enter------------------------------");

    NTSTATUS status;
    PDEVICE_CONTEXT pDeviceContext;
    WDF_USB_DEVICE_CREATE_CONFIG createParams;
    WDF_USB_DEVICE_SELECT_CONFIG_PARAMS configParams;

    UNREFERENCED_PARAMETER(ResourceList);
    UNREFERENCED_PARAMETER(ResourceListTranslated);

    PAGED_CODE();

    status = STATUS_SUCCESS;
    pDeviceContext = DeviceGetContext(Device);

    //
    // Create a USB device handle so that we can communicate with the
    // underlying USB stack. The WDFUSBDEVICE handle is used to query,
    // configure, and manage all aspects of the USB device.
    // These aspects include device properties, bus properties,
    // and I/O creation and synchronization. We only create the device the first time
    // PrepareHardware is called. If the device is restarted by pnp manager
    // for resource rebalance, we will use the same device handle but then select
    // the interfaces again because the USB stack could reconfigure the device on
    // restart.
    //
    if (pDeviceContext->UsbDevice == NULL) {

        //
        // Specifying a client contract version of 602 enables us to query for
        // and use the new capabilities of the USB driver stack for Windows 8.
        // It also implies that we conform to rules mentioned in MSDN
        // documentation for WdfUsbTargetDeviceCreateWithParameters.
        //
        WDF_USB_DEVICE_CREATE_CONFIG_INIT(&createParams,
                                         USBD_CLIENT_CONTRACT_VERSION_602
                                         );

        status = WdfUsbTargetDeviceCreateWithParameters(Device,
                                                    &createParams,
                                                    WDF_NO_OBJECT_ATTRIBUTES,
                                                    &pDeviceContext->UsbDevice
                                                    );

        if (!NT_SUCCESS(status)) {
			Err("WdfUsbTargetDeviceCreateWithParameters failed, status: 0x%x\n", status);
            return status;
        }
    }

    //
    // Select the first configuration of the device, using the first alternate
    // setting of each interface
    //
    WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_INIT_MULTIPLE_INTERFACES(&configParams,
                                                                 0,
                                                                 NULL
                                                                 );
    status = WdfUsbTargetDeviceSelectConfig(pDeviceContext->UsbDevice,
                                            WDF_NO_OBJECT_ATTRIBUTES,
                                            &configParams
                                            );

    if (!NT_SUCCESS(status)) {
		Err("WdfUsbTargetDeviceSelectConfig failed, status: 0x%x\n", status);
        return status;
    }
	Info("");
    return status;
}


/**
* @描述  得到内存
* @ParentDevice:创建设备的父对象
* @length：需要创建的长度
* @OutMemory:返回的内存对象，如果不需要可以传NULL
* @RETURN: 返回分配的缓冲区 如果失败返回NULL
*/
static PVOID HelpGetMemory(WDFOBJECT ParentDevice,
	int length,
	WDFMEMORY * OutMemory)
{
	Info("");

	NTSTATUS                 status = STATUS_SUCCESS;
	PVOID                    data = NULL;
	WDF_OBJECT_ATTRIBUTES  * pobjAttr = NULL;
	WDF_OBJECT_ATTRIBUTES    objectAttribs;
	WDFMEMORY                memoryHandle;

	if (ParentDevice != NULL)
	{
		WDF_OBJECT_ATTRIBUTES_INIT(&objectAttribs);
		objectAttribs.ParentObject = ParentDevice;

		pobjAttr = &objectAttribs;
	};

	status = WdfMemoryCreate(
		pobjAttr,
		NonPagedPool,
		'dcba',
		length,
		&memoryHandle,
		(PVOID)&data);
	if (!NT_SUCCESS(status))
	{
		Err("MemoryCreate failed:0x%x\n", status);
		return NULL;
	};

	if (OutMemory != NULL)
	{
		*OutMemory = memoryHandle;
	};

	return data;
};

/**
* @描述 释放内存
* @param 内存句柄
* @return
*/
static void HelpFreeMemory(WDFMEMORY memory)
{
	Info("");

	WdfObjectDelete(memory);
};

/**
* @描述 得到设备名称
* @param device USB设备
* @return	NULL 表示失败 其它值为指向缓冲区的指针，
缓冲区由FRAMEWORK自行释放
*/
static PVOID GetPhyDeviceName(WDFDEVICE Device)
{
	Info("");

	PVOID     str = NULL;
	ULONG     size = MAX_PATH;
	NTSTATUS  status = STATUS_SUCCESS;
	WDFMEMORY memory;
	ULONG     returnSize = 0;

	str = HelpGetMemory(Device, MAX_PATH, &memory);
	if (str == NULL)
	{
		Err("HelpGetMemory faled\n");
		goto EXIT;
	};

	status = WdfDeviceQueryProperty(Device,
		DevicePropertyPhysicalDeviceObjectName,
		size,
		str,
		&returnSize);

	if (!status)
	{
		Err("WdfQueryProperty faled 0x%x\n", status);
		goto EXIT;
	};

	return str;
EXIT:

	if (str != NULL)
	{
		HelpFreeMemory(memory);
	};

	return NULL;
};

/**
* @描述  初始化设备描述符
* @param device USB设备
* @return	TRUE表示成功  FALSE表示失败
*/
static BOOLEAN GetDeviceDesc(WDFDEVICE device)
{
	Info("");

	//PCAMERA_EXTENSION        extension     = NULL;
	USB_DEVICE_DESCRIPTOR    *desc         = NULL;
	NTSTATUS                 status        = STATUS_SUCCESS;
	PDEVICE_CONTEXT          deviceContext = NULL;

#if 0
	extension = GetExtension(Device);
	if (extension->DeviceData != NULL)
	{
		Err("have get device desc and return successful\n");
		return TRUE;
	}
#endif
	deviceContext = DeviceGetContext(device);

	desc = (USB_DEVICE_DESCRIPTOR*)
		HelpGetMemory(deviceContext->UsbDevice,
			sizeof(USB_DEVICE_DESCRIPTOR),
			NULL);
	if (desc == NULL)
	{
		Err("HelpGetMemory failed!\n");
		return FALSE;
	}

	WdfUsbTargetDeviceGetDeviceDescriptor(deviceContext->UsbDevice, desc);

	//extension->vendor = desc->idVendor;
	//extension->product = desc->idProduct;
	//extension->DeviceSize = sizeof(USB_DEVICE_DESCRIPTOR);
	//extension->DeviceData = (unsigned char*)desc;

	Info("vid:pid = 0x%04x:0x%04x", desc->idVendor, desc->idProduct);
	return TRUE;
};

/**
* @描述 添加设备到列表中
* @param UsbDevice USB设备
* @return
*/
static void DeviceListAdd(WDFDEVICE device)
{
	Info("");

	NTSTATUS            status        = STATUS_SUCCESS;
	ULONG               counts        = 0;
	int                 i             = 0;
	int                 skip          = 0;
	WCHAR               *name         = NULL;
	//PCAMERA_EXTENSION   extension     = NULL;
	PDEVICE_OBJECT      PhyDevice     = NULL;
	BOOLEAN             IsFind        = FALSE;
	WDFDEVICE           item;
	PDEVICE_CONTEXT     deviceContext = NULL;
	WDF_USB_DEVICE_CREATE_CONFIG  Config;

	PhyDevice = WdfDeviceWdmGetPhysicalDevice(device);

	//得到新到来设备的扩展
	//extension = GetExtension(Device);

	deviceContext = DeviceGetContext(device);

#if 0
//
// Network specific errors.
//
//
//
// MessageId: STATUS_NOT_SUPPORTED
//
// MessageText:
//
// The request is not supported.
//
#define STATUS_NOT_SUPPORTED             ((NTSTATUS)0xC00000BBL)

	status = WdfUsbTargetDeviceCreate(
		device,
		WDF_NO_OBJECT_ATTRIBUTES,
		&deviceContext->UsbDevice);

	Note  If you are building your driver using KMDF 1.11 or UMDF 2.0, or later, we recommend that you call
		  WdfUsbTargetDeviceCreateWithParameters instead of WdfUsbTargetDeviceCreate.
#endif

	WDF_USB_DEVICE_CREATE_CONFIG_INIT(
		&Config,
		USBD_CLIENT_CONTRACT_VERSION_602
	);
	status = WdfUsbTargetDeviceCreateWithParameters(
		device,
		&Config,
		WDF_NO_OBJECT_ATTRIBUTES,
		&deviceContext->UsbDevice
	);

	if (!NT_SUCCESS(status))
	{
		Err("Device failed status:0x%x\n", status);
		return;
	};

	status = GetDeviceDesc(device);
	if (!status)
	{
		Err("DeviceDesc failed\n");
		return;
	};

	name = (WCHAR*)GetPhyDeviceName(device);
	if (name != NULL)
	{
		Info("device name: %s", name);
	};
};

/**
* @描述  清理设备,删除设备
* @param Device USB设备
* @return
*/
static VOID DeviceCleanup(IN WDFDEVICE Device)
{
	PAGED_CODE();
#if 0
	L_FORCE_TRACE("device clean up enter\n");
	WdfWaitLockAcquire(s_DeviceListLock, NULL);
	WdfCollectionRemove(s_DeviceList, device);
	L_FORCE_TRACE("after del counts:%d\n",
	WdfCollectionGetCount(s_DeviceList));
	WdfWaitLockRelease(s_DeviceListLock);
#endif
};

